{"/home/travis/build/npmtest/node-npmtest-nconf/test.js":"/* istanbul instrument in package npmtest_nconf */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-nconf/lib.npmtest_nconf.js":"/* istanbul instrument in package npmtest_nconf */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_nconf = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_nconf = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-nconf/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-nconf && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_nconf */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_nconf\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_nconf.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        local.assetsDict['/assets.npmtest_nconf.rollup.js'] =\n            local.assetsDict['/assets.npmtest_nconf.rollup.js'] ||\n            local.fs.readFileSync(\n                // buildCustomOrg-hack\n                local.npmtest_nconf.__dirname +\n                    '/lib.npmtest_nconf.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-nconf/node_modules/nconf/lib/nconf.js":"/*\n * nconf.js: Top-level include for the nconf module\n *\n * (C) 2011, Charlie Robbins and the Contributors.\n *\n */\n\nvar fs = require('fs'),\n    async = require('async'),\n    common = require('./nconf/common'),\n    Provider = require('./nconf/provider').Provider;\n\n//\n// `nconf` is by default an instance of `nconf.Provider`.\n//\nvar nconf = module.exports = new Provider();\n\n//\n// Expose the version from the package.json\n//\nnconf.version = require('../package.json').version;\n\n//\n// Setup all stores as lazy-loaded getters.\n//\nfs.readdirSync(__dirname + '/nconf/stores').forEach(function (file) {\n  var store = file.replace('.js', ''),\n      name  = common.capitalize(store);\n\n  nconf.__defineGetter__(name, function () {\n    return require('./nconf/stores/' + store)[name];\n  });\n});\n\n//\n// Expose the various components included with nconf\n//\nnconf.key           = common.key;\nnconf.path          = common.path;\nnconf.loadFiles     = common.loadFiles;\nnconf.loadFilesSync = common.loadFilesSync;\nnconf.formats       = require('./nconf/formats');\nnconf.Provider      = Provider;\n\n","/home/travis/build/npmtest/node-npmtest-nconf/node_modules/nconf/lib/nconf/common.js":"/*\n * utils.js: Utility functions for the nconf module.\n *\n * (C) 2011, Charlie Robbins and the Contributors.\n *\n */\n\nvar fs = require('fs'),\n    async = require('async'),\n    formats = require('./formats'),\n    Memory = require('./stores/memory').Memory;\n\nvar common = exports;\n\n//\n// ### function path (key)\n// #### @key {string} The ':' delimited key to split\n// Returns a fully-qualified path to a nested nconf key.\n// If given null or undefined it should return an empty path.\n// '' should still be respected as a path.\n//\ncommon.path = function (key, separator) {\n  separator = separator || ':';\n  return key == null ? [] : key.split(separator);\n};\n\n//\n// ### function key (arguments)\n// Returns a `:` joined string from the `arguments`.\n//\ncommon.key = function () {\n  return Array.prototype.slice.call(arguments).join(':');\n};\n\n//\n// ### function key (arguments)\n// Returns a joined string from the `arguments`,\n// first argument is the join delimiter.\n//\ncommon.keyed = function () {\n  return Array.prototype.slice.call(arguments, 1).join(arguments[0]);\n};\n\n//\n// ### function loadFiles (files, callback)\n// #### @files {Object|Array} List of files (or settings object) to load.\n// #### @callback {function} Continuation to respond to when complete.\n// Loads all the data in the specified `files`.\n//\ncommon.loadFiles = function (files, callback) {\n  if (!files) {\n    return callback(null, {});\n  }\n\n  var options = Array.isArray(files) ? { files: files } : files;\n\n  //\n  // Set the default JSON format if not already\n  // specified\n  //\n  options.format = options.format || formats.json;\n\n  function parseFile (file, next) {\n    fs.readFile(file, function (err, data) {\n      return !err\n        ? next(null, options.format.parse(data.toString()))\n        : next(err);\n    });\n  }\n\n  async.map(options.files, parseFile, function (err, objs) {\n    return err ? callback(err) : callback(null, common.merge(objs));\n  });\n};\n\n//\n// ### function loadFilesSync (files)\n// #### @files {Object|Array} List of files (or settings object) to load.\n// Loads all the data in the specified `files` synchronously.\n//\ncommon.loadFilesSync = function (files) {\n  if (!files) {\n    return;\n  }\n\n  //\n  // Set the default JSON format if not already\n  // specified\n  //\n  var options = Array.isArray(files) ? { files: files } : files;\n  options.format = options.format || formats.json;\n\n  return common.merge(options.files.map(function (file) {\n    return options.format.parse(fs.readFileSync(file, 'utf8'));\n  }));\n};\n\n//\n// ### function merge (objs)\n// #### @objs {Array} Array of object literals to merge\n// Merges the specified `objs` using a temporary instance\n// of `stores.Memory`.\n//\ncommon.merge = function (objs) {\n  var store = new Memory();\n\n  objs.forEach(function (obj) {\n    Object.keys(obj).forEach(function (key) {\n      store.merge(key, obj[key]);\n    });\n  });\n\n  return store.store;\n};\n\n//\n// ### function capitalize (str)\n// #### @str {string} String to capitalize\n// Capitalizes the specified `str`.\n//\ncommon.capitalize = function (str) {\n  return str && str[0].toUpperCase() + str.slice(1);\n};\n","/home/travis/build/npmtest/node-npmtest-nconf/node_modules/nconf/lib/nconf/formats.js":"/*\n * formats.js: Default formats supported by nconf\n *\n * (C) 2011, Charlie Robbins and the Contributors.\n *\n */\n\nvar ini = require('ini');\n\nvar formats = exports;\n\n//\n// ### @json\n// Standard JSON format which pretty prints `.stringify()`.\n//\nformats.json = {\n  stringify: function (obj, replacer, spacing) {\n    return JSON.stringify(obj, replacer || null, spacing || 2)\n  },\n  parse: JSON.parse\n};\n\n//\n// ### @ini\n// Standard INI format supplied from the `ini` module\n// http://en.wikipedia.org/wiki/INI_file\n//\nformats.ini = ini;\n","/home/travis/build/npmtest/node-npmtest-nconf/node_modules/nconf/lib/nconf/stores/memory.js":"/*\n * memory.js: Simple memory storage engine for nconf configuration(s)\n *\n * (C) 2011, Charlie Robbins and the Contributors.\n *\n */\n\nvar common = require('../common');\n\n//\n// ### function Memory (options)\n// #### @options {Object} Options for this instance\n// Constructor function for the Memory nconf store which maintains\n// a nested json structure based on key delimiters `:`.\n//\n// e.g. `my:nested:key` ==> `{ my: { nested: { key: } } }`\n//\nvar Memory = exports.Memory = function (options) {\n  options       = options || {};\n  this.type     = 'memory';\n  this.store    = {};\n  this.mtimes   = {};\n  this.readOnly = false;\n  this.loadFrom = options.loadFrom || null;\n  this.logicalSeparator = options.logicalSeparator || ':';\n\n  if (this.loadFrom) {\n    this.store = common.loadFilesSync(this.loadFrom);\n  }\n};\n\n//\n// ### function get (key)\n// #### @key {string} Key to retrieve for this instance.\n// Retrieves the value for the specified key (if any).\n//\nMemory.prototype.get = function (key) {\n  var target = this.store,\n      path   = common.path(key, this.logicalSeparator);\n\n  //\n  // Scope into the object to get the appropriate nested context\n  //\n  while (path.length > 0) {\n    key = path.shift();\n    if (target && target.hasOwnProperty(key)) {\n      target = target[key];\n      continue;\n    }\n    return undefined;\n  }\n\n  return target;\n};\n\n//\n// ### function set (key, value)\n// #### @key {string} Key to set in this instance\n// #### @value {literal|Object} Value for the specified key\n// Sets the `value` for the specified `key` in this instance.\n//\nMemory.prototype.set = function (key, value) {\n  if (this.readOnly) {\n    return false;\n  }\n\n  var target = this.store,\n      path   = common.path(key, this.logicalSeparator);\n\n  if (path.length === 0) {\n    //\n    // Root must be an object\n    //\n    if (!value || typeof value !== 'object') {\n      return false;\n    }\n    else {\n      this.reset();\n      this.store = value;\n      return true;\n    }\n  }\n\n  //\n  // Update the `mtime` (modified time) of the key\n  //\n  this.mtimes[key] = Date.now();\n\n  //\n  // Scope into the object to get the appropriate nested context\n  //\n  while (path.length > 1) {\n    key = path.shift();\n    if (!target[key] || typeof target[key] !== 'object') {\n      target[key] = {};\n    }\n\n    target = target[key];\n  }\n\n  // Set the specified value in the nested JSON structure\n  key = path.shift();\n  target[key] = value;\n  return true;\n};\n\n//\n// ### function clear (key)\n// #### @key {string} Key to remove from this instance\n// Removes the value for the specified `key` from this instance.\n//\nMemory.prototype.clear = function (key) {\n  if (this.readOnly) {\n    return false;\n  }\n\n  var target = this.store,\n      value  = target,\n      path   = common.path(key, this.logicalSeparator);\n\n  //\n  // Remove the key from the set of `mtimes` (modified times)\n  //\n  delete this.mtimes[key];\n\n  //\n  // Scope into the object to get the appropriate nested context\n  //\n  for (var i = 0; i < path.length - 1; i++) {\n    key = path[i];\n    value = target[key];\n    if (typeof value !== 'function' && typeof value !== 'object') {\n      return false;\n    }\n    target = value;\n  }\n\n  // Delete the key from the nested JSON structure\n  key = path[i];\n  delete target[key];\n  return true;\n};\n\n//\n// ### function merge (key, value)\n// #### @key {string} Key to merge the value into\n// #### @value {literal|Object} Value to merge into the key\n// Merges the properties in `value` into the existing object value\n// at `key`. If the existing value `key` is not an Object, it will be\n// completely overwritten.\n//\nMemory.prototype.merge = function (key, value) {\n  if (this.readOnly) {\n    return false;\n  }\n\n  //\n  // If the key is not an `Object` or is an `Array`,\n  // then simply set it. Merging is for Objects.\n  //\n  if (typeof value !== 'object' || Array.isArray(value) || value === null) {\n    return this.set(key, value);\n  }\n\n  var self    = this,\n      target  = this.store,\n      path    = common.path(key, this.logicalSeparator),\n      fullKey = key;\n\n  //\n  // Update the `mtime` (modified time) of the key\n  //\n  this.mtimes[key] = Date.now();\n\n  //\n  // Scope into the object to get the appropriate nested context\n  //\n  while (path.length > 1) {\n    key = path.shift();\n    if (!target[key]) {\n      target[key] = {};\n    }\n\n    target = target[key];\n  }\n\n  // Set the specified value in the nested JSON structure\n  key = path.shift();\n\n  //\n  // If the current value at the key target is not an `Object`,\n  // or is an `Array` then simply override it because the new value\n  // is an Object.\n  //\n  if (typeof target[key] !== 'object' || Array.isArray(target[key])) {\n    target[key] = value;\n    return true;\n  }\n\n  return Object.keys(value).every(function (nested) {\n    return self.merge(common.keyed(self.logicalSeparator, fullKey, nested), value[nested]);\n  });\n};\n\n//\n// ### function reset (callback)\n// Clears all keys associated with this instance.\n//\nMemory.prototype.reset = function () {\n  if (this.readOnly) {\n    return false;\n  }\n\n  this.mtimes = {};\n  this.store  = {};\n  return true;\n};\n\n//\n// ### function loadSync\n// Returns the store managed by this instance\n//\nMemory.prototype.loadSync = function () {\n  return this.store || {};\n};\n","/home/travis/build/npmtest/node-npmtest-nconf/node_modules/nconf/lib/nconf/provider.js":"/*\n * provider.js: Abstraction providing an interface into pluggable configuration storage.\n *\n * (C) 2011, Charlie Robbins and the Contributors.\n *\n */\n\nvar async = require('async'),\n    common = require('./common');\n\n//\n// ### function Provider (options)\n// #### @options {Object} Options for this instance.\n// Constructor function for the Provider object responsible\n// for exposing the pluggable storage features of `nconf`.\n//\nvar Provider = exports.Provider = function (options) {\n  //\n  // Setup default options for working with `stores`,\n  // `overrides`, `process.env` and `process.argv`.\n  //\n  options       = options || {};\n  this.stores  = {};\n  this.sources = [];\n  this.init(options);\n};\n\n//\n// Define wrapper functions for using basic stores\n// in this instance\n//\n\n['argv', 'env'].forEach(function (type) {\n  Provider.prototype[type] = function () {\n    var args = [type].concat(Array.prototype.slice.call(arguments));\n    return this.add.apply(this, args);\n  };\n});\n\n//\n// ### function file (key, options)\n// #### @key {string|Object} Fully qualified options, name of file store, or path.\n// #### @path {string|Object} **Optional** Full qualified options, or path.\n// Adds a new `File` store to this instance. Accepts the following options\n//\n//    nconf.file({ file: '.jitsuconf', dir: process.env.HOME, search: true });\n//    nconf.file('path/to/config/file');\n//    nconf.file('userconfig', 'path/to/config/file');\n//    nconf.file('userconfig', { file: '.jitsuconf', search: true });\n//\nProvider.prototype.file = function (key, options) {\n  if (arguments.length == 1) {\n    options = typeof key === 'string' ? { file: key } : key;\n    key = 'file';\n  }\n  else {\n    options = typeof options === 'string'\n      ? { file: options }\n      : options;\n  }\n\n  options.type = 'file';\n  return this.add(key, options);\n};\n\n//\n// Define wrapper functions for using\n// overrides and defaults\n//\n['defaults', 'overrides'].forEach(function (type) {\n  Provider.prototype[type] = function (options) {\n    options = options || {};\n    if (!options.type) {\n      options.type = 'literal';\n    }\n\n    return this.add(type, options);\n  };\n});\n\n//\n// ### function use (name, options)\n// #### @type {string} Type of the nconf store to use.\n// #### @options {Object} Options for the store instance.\n// Adds (or replaces) a new store with the specified `name`\n// and `options`. If `options.type` is not set, then `name`\n// will be used instead:\n//\n//    provider.use('file');\n//    provider.use('file', { type: 'file', filename: '/path/to/userconf' })\n//\nProvider.prototype.use = function (name, options) {\n  options  = options      || {};\n  var type = options.type || name;\n\n  function sameOptions (store) {\n    return Object.keys(options).every(function (key) {\n      return options[key] === store[key];\n    });\n  }\n\n  var store = this.stores[name],\n      update = store && !sameOptions(store);\n\n  if (!store || update) {\n    if (update) {\n      this.remove(name);\n    }\n\n    this.add(name, options);\n  }\n\n  return this;\n};\n\n//\n// ### function add (name, options)\n// #### @name {string} Name of the store to add to this instance\n// #### @options {Object} Options for the store to create\n// Adds a new store with the specified `name` and `options`. If `options.type`\n// is not set, then `name` will be used instead:\n//\n//    provider.add('memory');\n//    provider.add('userconf', { type: 'file', filename: '/path/to/userconf' })\n//\nProvider.prototype.add = function (name, options, usage) {\n  options  = options      || {};\n  var type = options.type || name;\n\n  if (!require('../nconf')[common.capitalize(type)]) {\n    throw new Error('Cannot add store with unknown type: ' + type);\n  }\n\n  this.stores[name] = this.create(type, options, usage);\n\n  if (this.stores[name].loadSync) {\n    this.stores[name].loadSync();\n  }\n\n  return this;\n};\n\n//\n// ### function remove (name)\n// #### @name {string} Name of the store to remove from this instance\n// Removes a store with the specified `name` from this instance. Users\n// are allowed to pass in a type argument (e.g. `memory`) as name if\n// this was used in the call to `.add()`.\n//\nProvider.prototype.remove = function (name) {\n  delete this.stores[name];\n  return this;\n};\n\n//\n// ### function create (type, options)\n// #### @type {string} Type of the nconf store to use.\n// #### @options {Object} Options for the store instance.\n// Creates a store of the specified `type` using the\n// specified `options`.\n//\nProvider.prototype.create = function (type, options, usage) {\n  return new (require('../nconf')[common.capitalize(type.toLowerCase())])(options, usage);\n};\n\n//\n// ### function init (options)\n// #### @options {Object} Options to initialize this instance with.\n// Initializes this instance with additional `stores` or `sources` in the\n// `options` supplied.\n//\nProvider.prototype.init = function (options) {\n  var self = this;\n\n  //\n  // Add any stores passed in through the options\n  // to this instance.\n  //\n  if (options.type) {\n    this.add(options.type, options);\n  }\n  else if (options.store) {\n    this.add(options.store.name || options.store.type, options.store);\n  }\n  else if (options.stores) {\n    Object.keys(options.stores).forEach(function (name) {\n      var store = options.stores[name];\n      self.add(store.name || name || store.type, store);\n    });\n  }\n\n  //\n  // Add any read-only sources to this instance\n  //\n  if (options.source) {\n    this.sources.push(this.create(options.source.type || options.source.name, options.source));\n  }\n  else if (options.sources) {\n    Object.keys(options.sources).forEach(function (name) {\n      var source = options.sources[name];\n      self.sources.push(self.create(source.type || source.name || name, source));\n    });\n  }\n};\n\n//\n// ### function get (key, callback)\n// #### @key {string} Key to retrieve for this instance.\n// #### @callback {function} **Optional** Continuation to respond to when complete.\n// Retrieves the value for the specified key (if any).\n//\nProvider.prototype.get = function (key, callback) {\n  if (typeof key === 'function') {\n    // Allow a * key call to be made\n    callback = key;\n    key = null;\n  }\n\n  //\n  // If there is no callback we can short-circuit into the default\n  // logic for traversing stores.\n  //\n  if (!callback) {\n    return this._execute('get', 1, key, callback);\n  }\n\n  //\n  // Otherwise the asynchronous, hierarchical `get` is\n  // slightly more complicated because we do not need to traverse\n  // the entire set of stores, but up until there is a defined value.\n  //\n  var current = 0,\n      names = Object.keys(this.stores),\n      self = this,\n      response,\n      mergeObjs = [];\n\n  async.whilst(function () {\n    return typeof response === 'undefined' && current < names.length;\n  }, function (next) {\n    var store = self.stores[names[current]];\n    current++;\n\n    if (store.get.length >= 2) {\n      return store.get(key, function (err, value) {\n        if (err) {\n          return next(err);\n        }\n\n        response = value;\n\n        // Merge objects if necessary\n        if (response && typeof response === 'object' && !Array.isArray(response)) {\n          mergeObjs.push(response);\n          response = undefined;\n        }\n\n        next();\n      });\n    }\n\n    response = store.get(key);\n\n    // Merge objects if necessary\n    if (response && typeof response === 'object' && !Array.isArray(response)) {\n      mergeObjs.push(response);\n      response = undefined;\n    }\n\n    next();\n  }, function (err) {\n    if (!err && mergeObjs.length) {\n      response = common.merge(mergeObjs.reverse());\n    }\n    return err ? callback(err) : callback(null, response);\n  });\n};\n\n//\n// ### function set (key, value, callback)\n// #### @key {string} Key to set in this instance\n// #### @value {literal|Object} Value for the specified key\n// #### @callback {function} **Optional** Continuation to respond to when complete.\n// Sets the `value` for the specified `key` in this instance.\n//\nProvider.prototype.set = function (key, value, callback) {\n  return this._execute('set', 2, key, value, callback);\n};\n\n\n//\n// ### function required (keys)\n// #### @keys {array} List of keys\n// Throws an error if any of `keys` has no value, otherwise returns `true`\nProvider.prototype.required = function (keys) {\n  if (!Array.isArray(keys)) {\n    throw new Error('Incorrect parameter, array expected');\n  }\n\n  var missing = [];\n  keys.forEach(function(key) {\n    if (typeof this.get(key) === 'undefined') {\n      missing.push(key);\n    }\n  }, this);\n\n  if (missing.length) {\n    throw new Error('Missing required keys: ' + missing.join(', '));\n  } else {\n    return true;\n  }\n\n};\n\n//\n// ### function reset (callback)\n// #### @callback {function} **Optional** Continuation to respond to when complete.\n// Clears all keys associated with this instance.\n//\nProvider.prototype.reset = function (callback) {\n  return this._execute('reset', 0, callback);\n};\n\n//\n// ### function clear (key, callback)\n// #### @key {string} Key to remove from this instance\n// #### @callback {function} **Optional** Continuation to respond to when complete.\n// Removes the value for the specified `key` from this instance.\n//\nProvider.prototype.clear = function (key, callback) {\n  return this._execute('clear', 1, key, callback);\n};\n\n//\n// ### function merge ([key,] value [, callback])\n// #### @key {string} Key to merge the value into\n// #### @value {literal|Object} Value to merge into the key\n// #### @callback {function} **Optional** Continuation to respond to when complete.\n// Merges the properties in `value` into the existing object value at `key`.\n//\n// 1. If the existing value `key` is not an Object, it will be completely overwritten.\n// 2. If `key` is not supplied, then the `value` will be merged into the root.\n//\nProvider.prototype.merge = function () {\n  var self = this,\n      args = Array.prototype.slice.call(arguments),\n      callback = typeof args[args.length - 1] === 'function' && args.pop(),\n      value = args.pop(),\n      key = args.pop();\n\n  function mergeProperty (prop, next) {\n    return self._execute('merge', 2, prop, value[prop], next);\n  }\n\n  if (!key) {\n    if (Array.isArray(value) || typeof value !== 'object') {\n      return onError(new Error('Cannot merge non-Object into top-level.'), callback);\n    }\n\n    return async.forEach(Object.keys(value), mergeProperty, callback || function () { })\n  }\n\n  return this._execute('merge', 2, key, value, callback);\n};\n\n//\n// ### function load (callback)\n// #### @callback {function} Continuation to respond to when complete.\n// Responds with an Object representing all keys associated in this instance.\n//\nProvider.prototype.load = function (callback) {\n  var self = this;\n\n  function getStores () {\n    var stores = Object.keys(self.stores);\n    stores.reverse();\n    return stores.map(function (name) {\n      return self.stores[name];\n    });\n  }\n\n  function loadStoreSync(store) {\n    if (!store.loadSync) {\n      throw new Error('nconf store ' + store.type + ' has no loadSync() method');\n    }\n\n    return store.loadSync();\n  }\n\n  function loadStore(store, next) {\n    if (!store.load && !store.loadSync) {\n      return next(new Error('nconf store ' + store.type + ' has no load() method'));\n    }\n\n    return store.loadSync\n      ? next(null, store.loadSync())\n      : store.load(next);\n  }\n\n  function loadBatch (targets, done) {\n    if (!done) {\n      return common.merge(targets.map(loadStoreSync));\n    }\n\n    async.map(targets, loadStore, function (err, objs) {\n      return err ? done(err) : done(null, common.merge(objs));\n    });\n  }\n\n  function mergeSources (data) {\n    //\n    // If `data` was returned then merge it into\n    // the system store.\n    //\n    if (data && typeof data === 'object') {\n      self.use('sources', {\n        type: 'literal',\n        store: data\n      });\n    }\n  }\n\n  function loadSources () {\n    var sourceHierarchy = self.sources.splice(0);\n    sourceHierarchy.reverse();\n\n    //\n    // If we don't have a callback and the current\n    // store is capable of loading synchronously\n    // then do so.\n    //\n    if (!callback) {\n      mergeSources(loadBatch(sourceHierarchy));\n      return loadBatch(getStores());\n    }\n\n    loadBatch(sourceHierarchy, function (err, data) {\n      if (err) {\n        return callback(err);\n      }\n\n      mergeSources(data);\n      return loadBatch(getStores(), callback);\n    });\n  }\n\n  return self.sources.length\n    ? loadSources()\n    : loadBatch(getStores(), callback);\n};\n\n//\n// ### function save (callback)\n// #### @callback {function} **optional**  Continuation to respond to when\n// complete.\n// Instructs each provider to save.  If a callback is provided, we will attempt\n// asynchronous saves on the providers, falling back to synchronous saves if\n// this isn't possible.  If a provider does not know how to save, it will be\n// ignored.  Returns an object consisting of all of the data which was\n// actually saved.\n//\nProvider.prototype.save = function (value, callback) {\n  if (!callback && typeof value === 'function') {\n    callback = value;\n    value = null;\n  }\n\n  var self = this,\n      names = Object.keys(this.stores);\n\n  function saveStoreSync(memo, name) {\n    var store = self.stores[name];\n\n    //\n    // If the `store` doesn't have a `saveSync` method,\n    // just ignore it and continue.\n    //\n    if (store.saveSync) {\n      var ret = store.saveSync();\n      if (typeof ret == 'object' && ret !== null) {\n        memo.push(ret);\n      }\n    }\n    return memo;\n  }\n\n  function saveStore(memo, name, next) {\n    var store = self.stores[name];\n\n    //\n    // If the `store` doesn't have a `save` or saveSync`\n    // method(s), just ignore it and continue.\n    //\n\n    if (store.save) {\n      return store.save(value, function (err, data) {\n        if (err) {\n          return next(err);\n        }\n\n        if (typeof data == 'object' && data !== null) {\n          memo.push(data);\n        }\n\n        next(null, memo);\n      });\n    }\n    else if (store.saveSync) {\n      memo.push(store.saveSync());\n    }\n\n    next(null, memo);\n  }\n\n  //\n  // If we don't have a callback and the current\n  // store is capable of saving synchronously\n  // then do so.\n  //\n  if (!callback) {\n    return common.merge(names.reduce(saveStoreSync, []));\n  }\n\n  async.reduce(names, [], saveStore, function (err, objs) {\n    return err ? callback(err) : callback(null, common.merge(objs));\n  });\n};\n\n//\n// ### @private function _execute (action, syncLength, [arguments])\n// #### @action {string} Action to execute on `this.store`.\n// #### @syncLength {number} Function length of the sync version.\n// #### @arguments {Array} Arguments array to apply to the action\n// Executes the specified `action` on all stores for this instance, ensuring a callback supplied\n// to a synchronous store function is still invoked.\n//\nProvider.prototype._execute = function (action, syncLength /* [arguments] */) {\n  var args = Array.prototype.slice.call(arguments, 2),\n      callback = typeof args[args.length - 1] === 'function' && args.pop(),\n      destructive = ['set', 'clear', 'merge', 'reset'].indexOf(action) !== -1,\n      self = this,\n      response,\n      mergeObjs = [],\n      keys = Object.keys(this.stores);\n\n\n  function runAction (name, next) {\n    var store = self.stores[name];\n\n    if (destructive && store.readOnly) {\n      return next();\n    }\n\n    return store[action].length > syncLength\n      ? store[action].apply(store, args.concat(next))\n      : next(null, store[action].apply(store, args));\n  }\n\n  if (callback) {\n    return async.forEach(keys, runAction, function (err) {\n      return err ? callback(err) : callback();\n    });\n  }\n\n  keys.forEach(function (name) {\n    if (typeof response === 'undefined') {\n      var store = self.stores[name];\n\n      if (destructive && store.readOnly) {\n        return;\n      }\n\n      response = store[action].apply(store, args);\n\n      // Merge objects if necessary\n      if (response && action === 'get' && typeof response === 'object' && !Array.isArray(response)) {\n        mergeObjs.push(response);\n        response = undefined;\n      }\n    }\n  });\n\n  if (mergeObjs.length) {\n    response = common.merge(mergeObjs.reverse());\n  }\n\n  return response;\n}\n\n//\n// Throw the `err` if a callback is not supplied\n//\nfunction onError(err, callback) {\n  if (callback) {\n    return callback(err);\n  }\n\n  throw err;\n}\n","/home/travis/build/npmtest/node-npmtest-nconf/node_modules/nconf/lib/nconf/stores/argv.js":"/*\n * argv.js: Simple memory-based store for command-line arguments.\n *\n * (C) 2011, Charlie Robbins and the Contributors.\n *\n */\n\nvar util = require('util'),\n    Memory = require('./memory').Memory;\n\n//\n// ### function Argv (options)\n// #### @options {Object} Options for this instance.\n// Constructor function for the Argv nconf store, a simple abstraction\n// around the Memory store that can read command-line arguments.\n//\nvar Argv = exports.Argv = function (options, usage) {\n  Memory.call(this, options);\n\n  this.type     = 'argv';\n  this.readOnly = true;\n  this.options  = options || false;\n  this.usage    = usage;\n};\n\n// Inherit from the Memory store\nutil.inherits(Argv, Memory);\n\n//\n// ### function loadSync ()\n// Loads the data passed in from `process.argv` into this instance.\n//\nArgv.prototype.loadSync = function () {\n  this.loadArgv();\n  return this.store;\n};\n\n//\n// ### function loadArgv ()\n// Loads the data passed in from the command-line arguments\n// into this instance.\n//\nArgv.prototype.loadArgv = function () {\n  var self = this,\n      yargs, argv;\n\n  yargs = typeof this.options === 'object'\n    ? require('yargs')(process.argv.slice(2)).options(this.options)\n    : require('yargs')(process.argv.slice(2));\n\n  if (typeof this.usage === 'string') { yargs.usage(this.usage) }\n\n  argv = yargs.argv\n\n  if (!argv) {\n    return;\n  }\n\n  this.readOnly = false;\n  Object.keys(argv).forEach(function (key) {\n    if (typeof argv[key] !== 'undefined') {\n      self.set(key, argv[key]);\n    }\n  });\n\n  this.showHelp = yargs.showHelp\n  this.help     = yargs.help\n\n  this.readOnly = true;\n  return this.store;\n};\n","/home/travis/build/npmtest/node-npmtest-nconf/node_modules/nconf/lib/nconf/stores/env.js":"/*\n * env.js: Simple memory-based store for environment variables\n *\n * (C) 2011, Charlie Robbins and the Contributors.\n *\n */\n\nvar util = require('util'),\n    common = require('../common'),\n    Memory = require('./memory').Memory;\n\n//\n// ### function Env (options)\n// #### @options {Object} Options for this instance.\n// Constructor function for the Env nconf store, a simple abstraction\n// around the Memory store that can read process environment variables.\n//\nvar Env = exports.Env = function (options) {\n  Memory.call(this, options);\n\n  options        = options || {};\n  this.type      = 'env';\n  this.readOnly  = true;\n  this.whitelist = options.whitelist || [];\n  this.separator = options.separator || '';\n  this.lowerCase = options.lowerCase || false;\n\n  if (({}).toString.call(options.match) === '[object RegExp]'\n      && typeof options !== 'string') {\n    this.match = options.match;\n  }\n\n  if (options instanceof Array) {\n    this.whitelist = options;\n  }\n  if (typeof(options) === 'string') {\n    this.separator = options;\n  }\n};\n\n// Inherit from the Memory store\nutil.inherits(Env, Memory);\n\n//\n// ### function loadSync ()\n// Loads the data passed in from `process.env` into this instance.\n//\nEnv.prototype.loadSync = function () {\n  this.loadEnv();\n  return this.store;\n};\n\n//\n// ### function loadEnv ()\n// Loads the data passed in from `process.env` into this instance.\n//\nEnv.prototype.loadEnv = function () {\n  var self = this;\n\n  var env = process.env;\n\n  if (this.lowerCase) {\n    Object.keys(env).forEach(function (key) {\n      env[key.toLowerCase()] = env[key];\n    });\n  }\n\n  this.readOnly = false;\n  Object.keys(env).filter(function (key) {\n    if (self.match && self.whitelist.length) {\n      return key.match(self.match) || self.whitelist.indexOf(key) !== -1\n    }\n    else if (self.match) {\n      return key.match(self.match);\n    }\n    else {\n      return !self.whitelist.length || self.whitelist.indexOf(key) !== -1\n    }\n  }).forEach(function (key) {\n    if (self.separator) {\n      self.set(common.key.apply(common, key.split(self.separator)), env[key]);\n    }\n    else {\n      self.set(key, env[key]);\n    }\n  });\n\n  this.readOnly = true;\n  return this.store;\n};\n\n","/home/travis/build/npmtest/node-npmtest-nconf/node_modules/nconf/lib/nconf/stores/file.js":"/*\n * file.js: Simple file storage engine for nconf files\n *\n * (C) 2011, Charlie Robbins and the Contributors.\n *\n */\n\nvar crypto = require('crypto'),\n    fs = require('fs'),\n    path = require('path'),\n    util = require('util'),\n    Secure = require('secure-keys'),\n    formats = require('../formats'),\n    Memory = require('./memory').Memory,\n    exists = fs.exists || path.exists,\n    existsSync = fs.existsSync || path.existsSync;\n\n//\n// ### function File (options)\n// #### @options {Object} Options for this instance\n// Constructor function for the File nconf store, a simple abstraction\n// around the Memory store that can persist configuration to disk.\n//\nvar File = exports.File = function (options) {\n  if (!options || !options.file) {\n    throw new Error ('Missing required option `file`');\n  }\n\n  Memory.call(this, options);\n\n  this.type    = 'file';\n  this.file    = options.file;\n  this.dir     = options.dir    || process.cwd();\n  this.format  = options.format || formats.json;\n  this.secure  = options.secure;\n  this.spacing = options.json_spacing\n    || options.spacing\n    || 2;\n\n  if (this.secure) {\n    this.secure = Buffer.isBuffer(this.secure) || typeof this.secure === 'string'\n      ? { secret: this.secure.toString() }\n      : this.secure;\n\n    this.secure.alg = this.secure.alg || 'aes-256-ctr';\n    if (this.secure.secretPath) {\n      this.secure.secret = fs.readFileSync(this.secure.secretPath, 'utf8');\n    }\n\n    if (!this.secure.secret) {\n      throw new Error('secure.secret option is required');\n    }\n\n    this.keys = new Secure({\n      secret: this.secure.secret,\n      alg: this.secure.alg,\n      format: this.format\n    });\n  }\n\n  if (options.search) {\n    this.search(this.dir);\n  }\n};\n\n// Inherit from the Memory store\nutil.inherits(File, Memory);\n\n//\n// ### function save (value, callback)\n// #### @value {Object} _Ignored_ Left here for consistency\n// #### @callback {function} Continuation to respond to when complete.\n// Saves the current configuration object to disk at `this.file`\n// using the format specified by `this.format`.\n//\nFile.prototype.save = function (value, callback) {\n  if (!callback) {\n    callback = value;\n    value = null;\n  }\n\n  fs.writeFile(this.file, this.stringify(), callback);\n};\n\n//\n// ### function saveSync (value, callback)\n// #### @value {Object} _Ignored_ Left here for consistency\n// #### @callback {function} **Optional** Continuation to respond to when complete.\n// Saves the current configuration object to disk at `this.file`\n// using the format specified by `this.format` synchronously.\n//\nFile.prototype.saveSync = function (value) {\n  fs.writeFileSync(this.file, this.stringify());\n  return this.store;\n};\n\n//\n// ### function load (callback)\n// #### @callback {function} Continuation to respond to when complete.\n// Responds with an Object representing all keys associated in this instance.\n//\nFile.prototype.load = function (callback) {\n  var self = this;\n\n  exists(self.file, function (exists) {\n    if (!exists) {\n      return callback(null, {});\n    }\n\n    //\n    // Else, the path exists, read it from disk\n    //\n    fs.readFile(self.file, function (err, data) {\n      if (err) {\n        return callback(err);\n      }\n\n      try {\n        // Deals with string that include BOM\n        var stringData = data.toString();\n        if (stringData.charAt(0) === '\\uFEFF') {\n          stringData = stringData.substr(1);\n        }\n\n        self.store = self.parse(stringData);\n      }\n      catch (ex) {\n        return callback(new Error(\"Error parsing your configuration file: [\" + self.file + ']: ' + ex.message));\n      }\n\n      callback(null, self.store);\n    });\n  });\n};\n\n//\n// ### function loadSync (callback)\n// Attempts to load the data stored in `this.file` synchronously\n// and responds appropriately.\n//\nFile.prototype.loadSync = function () {\n  if (!existsSync(this.file)) {\n    this.store = {};\n    return this.store;\n  }\n\n  //\n  // Else, the path exists, read it from disk\n  //\n  try {\n    // Deals with file that include BOM\n    var fileData = fs.readFileSync(this.file, 'utf8');\n    if (fileData.charAt(0) === '\\uFEFF') {\n      fileData = fileData.substr(1);\n    }\n\n    this.store = this.parse(fileData);\n  }\n  catch (ex) {\n    throw new Error(\"Error parsing your configuration file: [\" + this.file + ']: ' + ex.message);\n  }\n\n  return this.store;\n};\n\n//\n// ### function stringify ()\n// Returns an encrypted version of the contents IIF\n// `this.secure` is enabled\n//\nFile.prototype.stringify = function () {\n  var data = this.store,\n      self = this;\n\n  if (this.secure) {\n    data = this.keys.encrypt(data);\n  }\n\n  return this.format.stringify(data, null, this.spacing);\n};\n\n//\n// ### function parse (contents)\n// Returns a decrypted version of the contents IFF\n// `this.secure` is enabled.\n//\nFile.prototype.parse = function (contents) {\n  var parsed = this.format.parse(contents),\n      self = this;\n\n  if (!this.secure) {\n    return parsed;\n  }\n\n  return this.keys.decrypt(parsed);\n\n};\n\n\n//\n// ### function search (base)\n// #### @base {string} Base directory (or file) to begin searching for the target file.\n// Attempts to find `this.file` by iteratively searching up the\n// directory structure\n//\nFile.prototype.search = function (base) {\n  var looking = true,\n      fullpath,\n      previous,\n      stats;\n\n  base = base || process.cwd();\n\n  if (this.file[0] === '/') {\n    //\n    // If filename for this instance is a fully qualified path\n    // (i.e. it starts with a `'/'`) then check if it exists\n    //\n    try {\n      stats = fs.statSync(fs.realpathSync(this.file));\n      if (stats.isFile()) {\n        fullpath = this.file;\n        looking = false;\n      }\n    }\n    catch (ex) {\n      //\n      // Ignore errors\n      //\n    }\n  }\n\n  if (looking && base) {\n    //\n    // Attempt to stat the realpath located at `base`\n    // if the directory does not exist then return false.\n    //\n    try {\n      var stat = fs.statSync(fs.realpathSync(base));\n      looking = stat.isDirectory();\n    }\n    catch (ex) {\n      return false;\n    }\n  }\n\n  while (looking) {\n    //\n    // Iteratively look up the directory structure from `base`\n    //\n    try {\n      stats = fs.statSync(fs.realpathSync(fullpath = path.join(base, this.file)));\n      looking = stats.isDirectory();\n    }\n    catch (ex) {\n      previous = base;\n      base = path.dirname(base);\n\n      if (previous === base) {\n        //\n        // If we've reached the top of the directory structure then simply use\n        // the default file path.\n        //\n        try {\n          stats = fs.statSync(fs.realpathSync(fullpath = path.join(this.dir, this.file)));\n          if (stats.isDirectory()) {\n            fullpath = undefined;\n          }\n        }\n        catch (ex) {\n          //\n          // Ignore errors\n          //\n        }\n\n        looking = false;\n      }\n    }\n  }\n\n  //\n  // Set the file for this instance to the fullpath\n  // that we have found during the search. In the event that\n  // the search was unsuccessful use the original value for `this.file`.\n  //\n  this.file = fullpath || this.file;\n\n  return fullpath;\n};\n","/home/travis/build/npmtest/node-npmtest-nconf/node_modules/nconf/lib/nconf/stores/literal.js":"/*\n * literal.js: Simple literal Object store for nconf.\n *\n * (C) 2011, Charlie Robbins and the Contributors.\n *\n */\n\nvar util = require('util'),\n    Memory = require('./memory').Memory\n\nvar Literal = exports.Literal = function Literal (options) {\n  Memory.call(this, options);\n\n  options       = options || {}\n  this.type     = 'literal';\n  this.readOnly = true;\n  this.store    = options.store || options;\n};\n\n// Inherit from Memory store.\nutil.inherits(Literal, Memory);\n\n//\n// ### function loadSync (callback)\n// Returns the data stored in `this.store` synchronously.\n//\nLiteral.prototype.loadSync = function () {\n  return this.store;\n};"}